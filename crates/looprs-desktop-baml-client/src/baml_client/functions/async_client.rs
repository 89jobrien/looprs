// This file was generated by BAML: do not edit it.
// Instead, edit the BAML source files.
//
// Learn more at https://docs.boundaryml.com

//! Asynchronous BAML client with function-object pattern.

use crate::baml_client::{
    runtime::{FunctionOptions, get_runtime},
    stream_types, types,
};
use baml::{AsyncStreamingCall, BamlEncode, BamlError};

// =============================================================================
// Convenience Builder Methods Macro
// =============================================================================

/// Implements convenience builder methods that delegate to `with_options`.
/// Requires the type to have:
/// - `options: FunctionOptions` field
/// - `fn with_options(&self, options: FunctionOptions) -> Self` method
macro_rules! impl_options_convenience_methods {
    ($name:ident) => {
        impl $name {
            pub fn with_collector(&self, collector: &baml::Collector) -> Self {
                self.with_options(self.options.clone().with_collector(collector))
            }

            pub fn with_collectors(&self, collectors: &[baml::Collector]) -> Self {
                self.with_options(self.options.clone().with_collectors(collectors))
            }

            pub fn with_cancellation_token(&self, token: Option<baml::CancellationToken>) -> Self {
                self.with_options(self.options.clone().with_cancellation_token(token))
            }

            pub fn with_type_builder(&self, tb: &super::super::type_builder::TypeBuilder) -> Self {
                self.with_options(self.options.clone().with_type_builder(tb))
            }

            pub fn with_env_var(&self, key: impl Into<String>, value: impl Into<String>) -> Self {
                self.with_options(self.options.clone().with_env_var(key, value))
            }

            pub fn with_tag(&self, key: impl Into<String>, value: impl Into<String>) -> Self {
                self.with_options(self.options.clone().with_tag(key, value))
            }

            pub fn with_client(&self, client_name: impl Into<String>) -> Self {
                self.with_options(self.options.clone().with_client(client_name))
            }

            pub fn with_client_registry(&self, registry: &baml::ClientRegistry) -> Self {
                self.with_options(self.options.clone().with_client_registry(registry))
            }
        }
    };
}

// =============================================================================
// Function Struct Macro (generates per-function struct with async methods)
// =============================================================================

macro_rules! baml_function_async {
    ($name:ident($($param:ident : $ptype:ty),* $(,)?) -> ($stream_ret:ty, $final_ret:ty)) => {
        #[derive(Clone)]
        pub struct $name {
            pub(crate) options: FunctionOptions,
        }

        impl $name {
            pub const fn new() -> Self {
                Self { options: FunctionOptions::new() }
            }

            fn with_options(&self, options: FunctionOptions) -> Self {
                Self { options }
            }

            // Terminal methods (async)
            pub async fn call(&self, $($param: $ptype),*) -> Result<$final_ret, BamlError> {
                let args = self.options.to_baml_args()
                    $(.arg(stringify!($param), $param.baml_encode()))*;
                get_runtime().call_function_async(stringify!($name), &args).await
            }

            pub fn stream(&self, $($param: $ptype),*) -> Result<AsyncStreamingCall<$stream_ret, $final_ret>, BamlError> {
                let args = self.options.to_baml_args()
                    $(.arg(stringify!($param), $param.baml_encode()))*;
                get_runtime().call_function_stream_async(stringify!($name), &args)
            }

            pub fn parse(&self, response: &str) -> Result<$final_ret, BamlError> {
                get_runtime().parse(stringify!($name), response, false)
            }

            pub fn parse_stream(&self, response: &str) -> Result<$stream_ret, BamlError> {
                get_runtime().parse(stringify!($name), response, true)
            }
        }

        // Builder convenience methods (separate impl block via macro)
        impl_options_convenience_methods!($name);
    };
}

// =============================================================================
// Generate function structs
// =============================================================================

baml_function_async!(AnalyzeIntent(user_input: impl AsRef<str> + BamlEncode, conversation_history: impl AsRef<str> + BamlEncode, ) -> (stream_types::UserIntent, types::UserIntent));

baml_function_async!(AnalyzeSentiment(text: impl AsRef<str> + BamlEncode, context: impl AsRef<str> + BamlEncode, ) -> (stream_types::MessageAnalysis, types::MessageAnalysis));

baml_function_async!(AssessSystemHealth(metrics: impl AsRef<str> + BamlEncode, ) -> (stream_types::SystemHealth, types::SystemHealth));

baml_function_async!(DetectAnomalies(metrics_history: impl AsRef<str> + BamlEncode, current_metrics: impl AsRef<str> + BamlEncode, ) -> (Vec<stream_types::DataAnomaly>, Vec<types::DataAnomaly>));

baml_function_async!(GenerateContextAwareUi(goal: impl AsRef<str> + BamlEncode, context: &types::UiContext, ) -> (stream_types::ContextAwareUiNode, types::ContextAwareUiNode));

baml_function_async!(GenerateDynamicText(template: impl AsRef<str> + BamlEncode, variables: &std::collections::HashMap<String, String>, sentiment: &types::Sentiment, mood: &types::Mood, ) -> (String, String));

baml_function_async!(GenerateSentimentAwareUi(goal: impl AsRef<str> + BamlEncode, state_json: impl AsRef<str> + BamlEncode, sentiment_analysis: impl AsRef<str> + BamlEncode, ) -> (stream_types::SentimentUiNode, types::SentimentUiNode));

baml_function_async!(GenerateUiTree(goal: impl AsRef<str> + BamlEncode, state_json: impl AsRef<str> + BamlEncode, ) -> (stream_types::UiNode, types::UiNode));

// =============================================================================
// Client Struct
// =============================================================================

#[derive(Clone)]
pub struct BamlAsyncClient {
    options: FunctionOptions,

    pub AnalyzeIntent: AnalyzeIntent,

    pub AnalyzeSentiment: AnalyzeSentiment,

    pub AssessSystemHealth: AssessSystemHealth,

    pub DetectAnomalies: DetectAnomalies,

    pub GenerateContextAwareUi: GenerateContextAwareUi,

    pub GenerateDynamicText: GenerateDynamicText,

    pub GenerateSentimentAwareUi: GenerateSentimentAwareUi,

    pub GenerateUiTree: GenerateUiTree,
}

impl BamlAsyncClient {
    pub const fn new() -> Self {
        Self {
            options: FunctionOptions::new(),

            AnalyzeIntent: AnalyzeIntent::new(),

            AnalyzeSentiment: AnalyzeSentiment::new(),

            AssessSystemHealth: AssessSystemHealth::new(),

            DetectAnomalies: DetectAnomalies::new(),

            GenerateContextAwareUi: GenerateContextAwareUi::new(),

            GenerateDynamicText: GenerateDynamicText::new(),

            GenerateSentimentAwareUi: GenerateSentimentAwareUi::new(),

            GenerateUiTree: GenerateUiTree::new(),
        }
    }

    /// Apply options to all functions. Returns a new client with the options set.
    pub fn with_options(&self, options: FunctionOptions) -> Self {
        Self {
            options: options.clone(),

            AnalyzeIntent: AnalyzeIntent {
                options: options.clone(),
            },

            AnalyzeSentiment: AnalyzeSentiment {
                options: options.clone(),
            },

            AssessSystemHealth: AssessSystemHealth {
                options: options.clone(),
            },

            DetectAnomalies: DetectAnomalies {
                options: options.clone(),
            },

            GenerateContextAwareUi: GenerateContextAwareUi {
                options: options.clone(),
            },

            GenerateDynamicText: GenerateDynamicText {
                options: options.clone(),
            },

            GenerateSentimentAwareUi: GenerateSentimentAwareUi {
                options: options.clone(),
            },

            GenerateUiTree: GenerateUiTree {
                options: options.clone(),
            },
        }
    }
}

// Builder convenience methods
impl_options_convenience_methods!(BamlAsyncClient);

pub static B: BamlAsyncClient = BamlAsyncClient::new();
