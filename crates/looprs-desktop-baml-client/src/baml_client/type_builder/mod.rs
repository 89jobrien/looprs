// This file was generated by BAML: do not edit it.
// Instead, edit the BAML source files.
//
// Learn more at https://docs.boundaryml.com

//! Generated TypeBuilder wrappers for type-safe schema access.

mod classes;
mod enums;

pub use classes::*;
pub use enums::*;

use std::sync::Arc;

/// TypeBuilder for dynamic type construction.
///
/// This wrapper provides access to the BAML TypeBuilder for creating
/// dynamic types at runtime. Use `TypeBuilder::new()` to create an instance.
///
/// Access schema-defined classes and enums via methods:
/// - `tb.ClassName()` returns the class builder
/// - `tb.EnumName()` returns the enum builder
#[derive(Clone)]
pub struct TypeBuilder {
    inner: Arc<baml::TypeBuilder>,
}

impl TypeBuilder {
    /// Create a new TypeBuilder for dynamic type construction.
    ///
    /// # Example
    /// ```ignore
    /// let tb = TypeBuilder::new();
    /// let my_enum = tb.add_enum("MyDynamicEnum")?;
    /// my_enum.add_value("Option1")?;
    /// ```
    pub fn new() -> Self {
        Self {
            inner: Arc::new(super::runtime::get_runtime().new_type_builder()),
        }
    }

    /// Get reference to inner TypeBuilder for FFI calls.
    pub(crate) fn inner(&self) -> &baml::TypeBuilder {
        &self.inner
    }

    // =========================================================================
    // Schema Class Accessors (1:1 with schema class names)
    // =========================================================================

    /// Access the `AdaptiveColors` class builder.
    pub fn AdaptiveColors(&self) -> AdaptiveColorsClassBuilder {
        AdaptiveColorsClassBuilder::new(
            self.inner
                .get_class("AdaptiveColors")
                .expect("class AdaptiveColors is defined in schema"),
        )
    }

    /// Access the `ContextAwareUiNode` class builder.
    pub fn ContextAwareUiNode(&self) -> ContextAwareUiNodeClassBuilder {
        ContextAwareUiNodeClassBuilder::new(
            self.inner
                .get_class("ContextAwareUiNode")
                .expect("class ContextAwareUiNode is defined in schema"),
        )
    }

    /// Access the `DataAnomaly` class builder.
    pub fn DataAnomaly(&self) -> DataAnomalyClassBuilder {
        DataAnomalyClassBuilder::new(
            self.inner
                .get_class("DataAnomaly")
                .expect("class DataAnomaly is defined in schema"),
        )
    }

    /// Access the `MaterialColors` class builder.
    pub fn MaterialColors(&self) -> MaterialColorsClassBuilder {
        MaterialColorsClassBuilder::new(
            self.inner
                .get_class("MaterialColors")
                .expect("class MaterialColors is defined in schema"),
        )
    }

    /// Access the `MessageAnalysis` class builder.
    pub fn MessageAnalysis(&self) -> MessageAnalysisClassBuilder {
        MessageAnalysisClassBuilder::new(
            self.inner
                .get_class("MessageAnalysis")
                .expect("class MessageAnalysis is defined in schema"),
        )
    }

    /// Access the `SentimentContext` class builder.
    pub fn SentimentContext(&self) -> SentimentContextClassBuilder {
        SentimentContextClassBuilder::new(
            self.inner
                .get_class("SentimentContext")
                .expect("class SentimentContext is defined in schema"),
        )
    }

    /// Access the `SentimentUiNode` class builder.
    pub fn SentimentUiNode(&self) -> SentimentUiNodeClassBuilder {
        SentimentUiNodeClassBuilder::new(
            self.inner
                .get_class("SentimentUiNode")
                .expect("class SentimentUiNode is defined in schema"),
        )
    }

    /// Access the `SystemHealth` class builder.
    pub fn SystemHealth(&self) -> SystemHealthClassBuilder {
        SystemHealthClassBuilder::new(
            self.inner
                .get_class("SystemHealth")
                .expect("class SystemHealth is defined in schema"),
        )
    }

    /// Access the `UiContext` class builder.
    pub fn UiContext(&self) -> UiContextClassBuilder {
        UiContextClassBuilder::new(
            self.inner
                .get_class("UiContext")
                .expect("class UiContext is defined in schema"),
        )
    }

    /// Access the `UiNode` class builder.
    pub fn UiNode(&self) -> UiNodeClassBuilder {
        UiNodeClassBuilder::new(
            self.inner
                .get_class("UiNode")
                .expect("class UiNode is defined in schema"),
        )
    }

    /// Access the `UserIntent` class builder.
    pub fn UserIntent(&self) -> UserIntentClassBuilder {
        UserIntentClassBuilder::new(
            self.inner
                .get_class("UserIntent")
                .expect("class UserIntent is defined in schema"),
        )
    }

    /// Access the `WorkflowState` class builder.
    pub fn WorkflowState(&self) -> WorkflowStateClassBuilder {
        WorkflowStateClassBuilder::new(
            self.inner
                .get_class("WorkflowState")
                .expect("class WorkflowState is defined in schema"),
        )
    }

    // =========================================================================
    // Schema Enum Accessors (1:1 with schema enum names)
    // =========================================================================

    /// Access the `AnomalySeverity` enum builder.
    pub fn AnomalySeverity(&self) -> AnomalySeverityEnumBuilder {
        AnomalySeverityEnumBuilder::new(
            self.inner
                .get_enum("AnomalySeverity")
                .expect("enum AnomalySeverity is defined in schema"),
        )
    }

    /// Access the `AnomalyType` enum builder.
    pub fn AnomalyType(&self) -> AnomalyTypeEnumBuilder {
        AnomalyTypeEnumBuilder::new(
            self.inner
                .get_enum("AnomalyType")
                .expect("enum AnomalyType is defined in schema"),
        )
    }

    /// Access the `HealthStatus` enum builder.
    pub fn HealthStatus(&self) -> HealthStatusEnumBuilder {
        HealthStatusEnumBuilder::new(
            self.inner
                .get_enum("HealthStatus")
                .expect("enum HealthStatus is defined in schema"),
        )
    }

    /// Access the `IntentCategory` enum builder.
    pub fn IntentCategory(&self) -> IntentCategoryEnumBuilder {
        IntentCategoryEnumBuilder::new(
            self.inner
                .get_enum("IntentCategory")
                .expect("enum IntentCategory is defined in schema"),
        )
    }

    /// Access the `Mood` enum builder.
    pub fn Mood(&self) -> MoodEnumBuilder {
        MoodEnumBuilder::new(
            self.inner
                .get_enum("Mood")
                .expect("enum Mood is defined in schema"),
        )
    }

    /// Access the `Sentiment` enum builder.
    pub fn Sentiment(&self) -> SentimentEnumBuilder {
        SentimentEnumBuilder::new(
            self.inner
                .get_enum("Sentiment")
                .expect("enum Sentiment is defined in schema"),
        )
    }

    /// Access the `Severity` enum builder.
    pub fn Severity(&self) -> SeverityEnumBuilder {
        SeverityEnumBuilder::new(
            self.inner
                .get_enum("Severity")
                .expect("enum Severity is defined in schema"),
        )
    }

    /// Access the `WorkflowStage` enum builder.
    pub fn WorkflowStage(&self) -> WorkflowStageEnumBuilder {
        WorkflowStageEnumBuilder::new(
            self.inner
                .get_enum("WorkflowStage")
                .expect("enum WorkflowStage is defined in schema"),
        )
    }

    // =========================================================================
    // Primitive Types (all infallible)
    // =========================================================================

    /// Get the string type.
    pub fn string(&self) -> baml::TypeDef {
        self.inner.string()
    }

    /// Get the int type.
    pub fn int(&self) -> baml::TypeDef {
        self.inner.int()
    }

    /// Get the float type.
    pub fn float(&self) -> baml::TypeDef {
        self.inner.float()
    }

    /// Get the bool type.
    pub fn bool(&self) -> baml::TypeDef {
        self.inner.bool()
    }

    /// Get the null type.
    pub fn null(&self) -> baml::TypeDef {
        self.inner.null()
    }

    // =========================================================================
    // Literal Types (all infallible)
    // =========================================================================

    /// Create a literal string type.
    pub fn literal_string(&self, value: &str) -> baml::TypeDef {
        self.inner.literal_string(value)
    }

    /// Create a literal int type.
    pub fn literal_int(&self, value: i64) -> baml::TypeDef {
        self.inner.literal_int(value)
    }

    /// Create a literal bool type.
    pub fn literal_bool(&self, value: bool) -> baml::TypeDef {
        self.inner.literal_bool(value)
    }

    // =========================================================================
    // Composite Types (all infallible)
    // =========================================================================

    /// Create a list type.
    pub fn list(&self, inner: &baml::TypeDef) -> baml::TypeDef {
        self.inner.list(inner)
    }

    /// Create an optional type.
    pub fn optional(&self, inner: &baml::TypeDef) -> baml::TypeDef {
        self.inner.optional(inner)
    }

    /// Create a map type.
    pub fn map(&self, key: &baml::TypeDef, value: &baml::TypeDef) -> baml::TypeDef {
        self.inner.map(key, value)
    }

    /// Create a union type.
    pub fn union(&self, types: &[&baml::TypeDef]) -> baml::TypeDef {
        self.inner.union(types)
    }

    // =========================================================================
    // Schema Operations (fallible)
    // =========================================================================

    /// Add BAML schema definitions.
    pub fn add_baml(&self, baml_source: &str) -> Result<(), baml::BamlError> {
        self.inner.add_baml(baml_source)
    }

    /// Print the TypeBuilder state for debugging.
    pub fn print(&self) -> String {
        self.inner.print()
    }

    // =========================================================================
    // Dynamic Enum Operations
    // =========================================================================

    /// Add a new dynamic enum.
    pub fn add_enum(&self, name: &str) -> Result<baml::EnumBuilder, baml::BamlError> {
        self.inner.add_enum(name)
    }

    /// Get an enum by name (returns None if not found).
    pub fn get_enum(&self, name: &str) -> Option<baml::EnumBuilder> {
        self.inner.get_enum(name)
    }

    /// List all enums.
    pub fn list_enums(&self) -> Vec<baml::EnumBuilder> {
        self.inner.list_enums()
    }

    // =========================================================================
    // Dynamic Class Operations
    // =========================================================================

    /// Add a new dynamic class.
    pub fn add_class(&self, name: &str) -> Result<baml::ClassBuilder, baml::BamlError> {
        self.inner.add_class(name)
    }

    /// Get a class by name (returns None if not found).
    pub fn get_class(&self, name: &str) -> Option<baml::ClassBuilder> {
        self.inner.get_class(name)
    }

    /// List all classes.
    pub fn list_classes(&self) -> Vec<baml::ClassBuilder> {
        self.inner.list_classes()
    }
}

impl Default for TypeBuilder {
    fn default() -> Self {
        Self::new()
    }
}

impl std::fmt::Debug for TypeBuilder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TypeBuilder")
            .field("state", &self.print())
            .finish()
    }
}
